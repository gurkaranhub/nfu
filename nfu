#!/usr/bin/env perl
# nfu: Command-line numeric fu | Spencer Tipping
# Licensed under the terms of the MIT source code license

use v5.14;
use strict;
use warnings;
use POSIX qw(dup2);

$|++;

my %explosions = (
  a => '--average',
  c => '--count',
  d => '--delta',
  e => '--eval',
  E => '--every',
  f => '--fields',
  F => '--fieldsplit',
  g => '--group',
  G => '--rgroup',
  j => '--json',
  l => '--log',
  L => '--exp',
  o => '--order',
  O => '--rorder',
  s => '--sum',
  S => '--slice',
  q => '--quant',
  p => '--plot',
  P => '--poll',
  r => '--reduce',
);

my %arity = (
  average    => 1,
  count      => 0,
  delta      => 0,
  eval       => 1,
  every      => 1,
  fields     => 1,
  fieldsplit => 1,
  group      => 0,
  rgroup     => 0,
  json       => 1,
  log        => 0,
  exp        => 0,
  order      => 0,
  rorder     => 0,
  plot       => 1,
  poll       => 2,
  sum        => 0,
  slice      => 2,
  quant      => 1,
  reduce     => 2,
);

sub exec_with_diamond {
  if (@ARGV) {
    # Arguments are specified in filenames and may be compressed, so use perl
    # to forward data.
    open(my $fh, '|' . join(' ', map {"'$_'"} @_)) or die "failed to exec @_";
    print $fh $_ while <>;
    close $fh;
  } else {
    # Faster option: just exec the program in-place. This avoids a layer of
    # interprocess piping.
    exec @_ or die "failed to exec @_";
  }
}

sub sort_options {
  '-S', $ENV{NFU_SORT_BUFFER} || '256M',
  '--parallel=' . ($ENV{NFU_SORT_PARALLEL} || 4),
  ($ENV{NFU_SORT_COMPRESS} ? ("--compress-program=$ENV{NFU_SORT_COMPRESS}")
                           : ())
}

my %functions = (
  group  => sub {exec_with_diamond 'sort', sort_options},
  rgroup => sub {exec_with_diamond 'sort', '-r', sort_options},
  order  => sub {exec_with_diamond 'sort', '-n', sort_options},
  rorder => sub {exec_with_diamond 'sort', '-rn', sort_options},

  count  => [
    [qw/count last/],
    q{# Same behavior as uniq -c, but delimits counts with \t
      chomp(my $last = <>);
      my $count = 1},

    q{if (LINE eq $last) {
        ++$count;
      } else {
        EMIT($count, $last);
        $count = 1;
        $last  = LINE;
      }},

    q{EMIT($count, $last)}],

  average => [
    [qw/size n total window x xs/],
    q{my $size = $_[0];
      my ($n, $total) = (0, 0);
      my @window = ();},

    q{my ($x, @xs) = SPLIT;
      EMIT(($total += $x) /
           (++$n > $size && $size ? $size : $n), @xs);
      $total -= shift @window if $size and push(@window, $x) >= $size}],

  slice => [
    [qw/chop_head chop_tail window n/],
    q{my ($chop_head, $chop_tail) = @_;
      die "usage: --slice head tail, or -Shead,tail"
        unless defined $chop_head and defined $chop_tail
           and $chop_head =~ /^\d+$/ and $chop_tail =~ /^\d+$/;
      my @window;
      my $n = 0},
    q{push @window, LINE if ++$n > $chop_head;
      EMITLINE(shift @window) if @window > $chop_tail}],

  log => [
    [qw/x xs/],
    q{},
    q{my ($x, @xs) = SPLIT;
      EMIT(log($x), @xs)}],

  exp => [
    [qw/x xs/],
    q{},
    q{my ($x, @xs) = SPLIT;
      EMIT(exp($x), @xs)}],

  plot => sub {exec_with_diamond 'gnuplot', '-e', "plot \"-\" @_", '-persist'},

  poll => [
    [qw/sleep command/],
    q{my ($sleep, $command) = @_;
      die "usage: --poll sleep-amount 'command ...'"
        unless defined $sleep and defined $command},
    q{EMITLINE(qx|$command|), sleep $sleep while 1}],

  delta => [
    [qw/last x xs/],
    q{my $last = 0},
    q{my ($x, @xs) = SPLIT;
      EMIT($x - $last, @xs);
      $last = $x}],

  sum => [
    [qw/total x xs/],
    q{my $total = 0},
    q{my ($x, @xs) = SPLIT;
      EMIT($total += $x, @xs)}],

  quant => [
    [qw/quantum x xs sign/],
    q{my $quantum = $_[0] || 1.0},
    q{my ($x, @xs) = SPLIT;
      my $sign = $x < 0 ? -1 : 1;
      EMIT(int(abs($x) / $quantum + 0.5) * $quantum * $sign, @xs)}],

  eval => [
    [qw/code f xs ys/],
    q{(my $code = $_[0]) =~ s/%(\d+)/\$_[$1]/g;
      my $f = eval "sub {\n" . $code . "\n}" or
              die "failed to compile eval function: $@\n  (code was $code)";
      local $_ = ''},
    q{my @xs = SPLIT;
      my @ys = $f->(@xs);
      EMIT(@ys > 1 ? @ys
                     ($ys[0], @xs[1 .. $#xs])) if @ys}],

  reduce => [
    [qw/code f xs ys/],
    q{(my $code = $_[1]) =~ s/%(\d+)/\$_[$1]/g;
      my $f = eval "sub {\n" . $code . "\n}" or
              die "failed to compile eval function: $@\n  (code was $code)";
      local $_ = $_[0]},
    q{my @xs = SPLIT;
      my @ys = $f->(@xs);
      EMIT(@ys > 1 ? @ys
                     ($ys[0], @xs[1 .. $#xs])) if @ys}],

  json => [
    [qw/body json code f xs ys/],
    q{require JSON or die 'nfu: unable to load JSON module';
      JSON->import;

      no warnings qw(uninitialized);

      my $body = $_[0] =~ s/%(\d+)/\$_[$1]/gr
                       =~ s/\.(\w+)/->{'$1'}/gr;

      my $json = JSON->new->allow_nonref->utf8(1);
      my $code = qq{sub {
        local \$_ = \$json->decode(\$_[0]);
        $body;
      }};

      my $f = eval $code
              or die "failed to compile eval function: $@\n  (code was $code)"},

    q{my @xs = SPLIT;
      my @ys = $f->(@xs);
      EMIT(@ys > 1 ? @ys
                   : ($json->encode($ys[0]), @xs[1 .. $#xs]))
      if @ys}],

  every => [
    [qw/n i/],
    q{my ($n) = @_;
      my $i = 0},
    q{EMIT(SPLIT) unless $i++ % $n}],

  fields => [
    [qw/fs/],
    q{my @fs = split //, $_[0]},
    q{EMIT((SPLIT)[@fs])}],

  fieldsplit => [
    [qw/delim/],
    q{my $delim = qr/$_[0]/},
    q{EMIT(split /$delim/, LINE)}],
);

our $gensym_id = 0;
sub replace_locals {
  my ($f, @locals) = @_;
  $f =~ s/\b($_)\b/__$gensym_id$1__/g for @locals;
  $f;
}

sub line {print @_, "\n"}
sub enqueue(\@@) {push $_[0], [@_[1..$#_]]}

sub compile_one {
  # Takes a single command and some compiler directives, and returns an array
  # of (init, body, final).
  my ($is_first, $is_last, $command, @args) = @_;
  s/([\\'])/\\$1/g for @args;

  ++$gensym_id;

  my $quoted_args  = join ', ', map "'$_'", @args;
  my $init_form    = "\@_ = ($quoted_args);\n"
                   . replace_locals($command->[1] // '', @{$command->[0]})
                   . "\n;";

  my $emitter      = $is_last ? 'line join "\t", '
                              : 'enqueue @_line_queue, ';
  my $line_emitter = $is_last ? 'line '
                              : 'enqueue @_line_queue, split /\\t/, ';

  my $line         = $is_first ? '$_line' : 'join("\\t", @_split)';
  my $split        = '@_split';

  my $body_form    = replace_locals($command->[2] // '', @{$command->[0]});
  $body_form =~ s/\bEMIT\b/$emitter/g;
  $body_form =~ s|\bEMIT_LINE\b|$emitter split /\\t/, |g;
  $body_form =~ s/\bLINE\b/$line/g;
  $body_form =~ s/\bSPLIT\b/$split/g;

  my $final_form   = replace_locals($command->[3] // '', @{$command->[0]});
  $final_form =~ s/\bEMIT\b/$emitter/g;
  $final_form =~ s|\bEMIT_LINE\b|$emitter split /\\t/, |g;
  $final_form =~ s/\bLINE\b/$line/g;
  $final_form =~ s/\bSPLIT\b/$split/g;

  ($init_form, $body_form, $final_form);
}

sub compile {
  # Takes one or more fused commands and compiles a new Perl function to
  # execute them. Fused commands should be in the form [command_name, [@args]].
  my @commands    = @_;
  my @init_stuff  = ();
  my @body_stuff  = ();
  my @final_stuff = ();

  for (my $i = 0; $i < @commands; ++$i) {
    my ($init, $body, $final) = compile_one $i == 0,
                                            $i == $#commands,
                                            $commands[$i][0],
                                            @{$commands[$i][1]};

    push @init_stuff,  $init  if length $init;
    push @body_stuff,  $body  if length $body;
    push @final_stuff, $final if length $final;
  }

  my $compiled_init = join "\n", @init_stuff;
  my $compiled_body =
    join "\n",
    map '@_lines = @_line_queue;'
      . '@_line_queue = ();'
      . 'for my $_line (@_lines) {@_split = @$_line;'
      . "$_\n;\n}", @body_stuff;

  my $compiled_final =
    join "\n",
    map '@_lines = @_line_queue;'
      . '@_line_queue = ();'
      . 'for my $_line (@_lines) {@_split = @$_line;'
      . "$_\n;\n}", @final_stuff;

  my $code = qq{sub {
    $compiled_init
    my \@_lines;
    my \@_line_queue;
    my \$_line;
    my \@_split;
    while (defined(\$_line = <>)) {
      \@_split = split /\\t/, \$_line;
      \@_line_queue = [\@_split];
      $compiled_body
    }
    $compiled_final
  }};

  print STDERR "compiling $code";

  my $subref = eval $code;
  die "compilation error: $@ (compiling $code)" if $@;
  $subref;
}

sub explode {
  return $_ unless s/^-([^-])/$1/;
  map {$explosions{$_} // $_} grep length, split /([.\d]*),?/;
}

$SIG{CHLD} = 'IGNORE';

my $reader   = undef;
my @exploded = map explode, @ARGV;
my @parsed   = ();
my $type     = 'CODE';

@ARGV = ();

# First parse through all of the options, pull out stray files, and replace
# @ARGV. This enables <> in the worker subs. (The "right way" to do this would
# be to chain the commands' inputs; then I could remove the branch in the while
# loop below. But I'm too lazy.)
while (@exploded) {
  (my $command = shift @exploded) =~ s/^--//;

  if (defined(my $arity = $arity{$command})) {
    my @args = splice @exploded, 0, $arity;
    push @parsed, [$command, [@args]];
  } elsif (-f $command) {
    # It's really a filename, so push it onto @ARGV. If it's compressed, run it
    # through the appropriate decompressor first.
    push @ARGV, $command =~ s/^(.*\.gz)/zcat $1 |/ri
                         =~ s/^(.*\.bz2)/bzcat $1 |/ri
                         =~ s/^(.*\.xz)/xz -dc $1 |/ri
                         =~ s/^(.*\.lzo)/lzop -dc $1 |/ri;
  } else {
    die "nonexistent command/file: $command";
  }
}

$$_[0] = $functions{$$_[0]} for @parsed;

my $subref = compile @parsed;
&$subref();
exit;

if (@parsed) {
  # Note: the loop below uses pipe/fork/dup2 instead of a more idiomatic Open2
  # call. I don't have a good reason for this other than to figure out how the
  # low-level stuff worked.
  for (my $i = 0; $i < @parsed; ++$i) {
    my ($command, @args) = @{$parsed[$i]};

    # Here's where things get fun. The question right now is, "do we need to
    # fork, or can we run in-process?" -- i.e. are we in the middle, or at the
    # end? When we're in the middle, we want to redirect STDOUT to the pipe's
    # writer and fork; otherwise we run in-process and write directly to the
    # existing STDOUT.
    if ($i < @parsed - 1) {
      # We're in the middle, so allocate a pipe and fork.
      pipe my($new_reader), my($writer);
      unless (fork) {
        # We're the child, so do STDOUT redirection.
        close $new_reader or die "failed to close pipe reader: $!";
        dup2(fileno($reader), 0) or die "failed to dup input: $!"
          if defined $reader;
        dup2(fileno($writer), 1) or die "failed to dup stdout: $!";

        close $reader or die "failed to close reader: $!" if defined $reader;
        close $writer or die "failed to close writer: $!";

        # The function here may never return.
        $functions{$command}->(@args);
        exit;
      } else {
        close $writer or die "failed to close pipe writer: $!";
        $reader = $new_reader;
      }
    } else {
      # We've hit the end of the chain. Preserve stdout, redirect stdin from
      # current reader.
      dup2(fileno($reader), 0) or die "failed to dup input: $!"
        if defined $reader;
      $functions{$command}->(@args);
    }

    # Prevent <> from reading files after the first iteration (this is such a
    # hack).
    @ARGV = ();
  }
} else {
  # Behave like cat, which is useful for auto-decompressing things.
  print while <>;
}
