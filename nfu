#!/usr/bin/env perl
# nfu: Command-line numeric fu | Spencer Tipping
# Licensed under the terms of the MIT source code license

use v5.14;
use strict;
use warnings;

use Time::HiRes qw/time/;
use POSIX       qw/dup2 mkfifo :sys_wait_h/;
use File::Temp  qw/tmpnam/;

use constant VERBOSE_INTERVAL => 30;

++$|;

# Setup child capture. All we need to do is wait for child pids; there's no
# formal teardown.
$SIG{CHLD} = sub {
  local ($!, $?);
  waitpid -1, WNOHANG;
};

# NB: This import is not used in nfu directly; it's here so you can use these
# functions inside aggregators.
use List::Util qw(first max maxstr min minstr reduce shuffle sum);

# Same for this, which is especially useful from aggregators because multiple
# values create multiple output rows, not multiple columns on the same output
# row.
sub row {join "\t", @_}

# Order-preserving unique values for strings. This is just too useful not to
# provide.
sub uniq {
  my %seen;
  my @order;
  $seen{$_}++ or push @order, $_ for @_;
  @order;
}

sub frequencies {
  my %freqs;
  ++$freqs{$_} for @_;
  %freqs;
}

sub mean {scalar @_ && sum(@_) / @_}

# JSON support (if available)
our $json;
if (require JSON) {
  JSON->import;
  no warnings qw(uninitialized);
  $json = JSON->new->allow_nonref->utf8(1);
} else {
  print STDERR "note: no JSON support detected (try 'cpan install JSON')\n";
}

# These are callable from evaled code
sub json_encode {$json->encode(@_)}
sub json_decode {$json->decode(@_)}

sub je {json_encode @_}
sub jd {json_decode @_}

# File functions
sub expand_filename_shorthands {
  my ($f, $always_make_a_command) = @_;
  my $result;
  if (-e $f) {
    # It's really a filename, so push it onto @ARGV. If it's compressed, run it
    # through the appropriate decompressor first.
    my $piped = $f =~ s/^(.*\.gz)/cat '$1' | gzip -d/ri
                   =~ s/^(.*\.bz2)/cat '$1' | bzip -d/ri
                   =~ s/^(.*\.xz)/cat '$1' | xz -d/ri
                   =~ s/^(.*\.lzo)/cat '$1' | lzop -d/ri;
    $result = $piped =~ /\|/ ? "$piped |" : $piped;
  } elsif ($f =~ s/^(?:http(s?):)?\/\//"http" . ($1 || '') . ":\/\/"/e) {
    # Assume a URL and curl it
    $result = "curl $f |";
  } elsif ($f =~ s/^sh://) {
    # Execute a command and capture stdout
    $result = "$f |";
  } elsif ($f =~ /(\w*@?[^:]+):(.*)$/) {
    # Access file over SSH
    $result = "ssh -C '$1' cat '$2' |";
  } else {
    return undef;
  }

  $always_make_a_command && $result !~ /\|/ ? "cat '$result' |"
                                            : $result;
}

sub read_file {
  open my $fh, '<', $_[0];
  join '', <$fh>;
}

sub read_lines {
  open my $fh, '<', $_[0];
  my @result;
  chomp, push @result, $_ for <$fh>;
  @result;
}

# Flags
our $verbose    = 0;
our $n_lines    = 0;
our $n_bytes    = 0;
our $start_time = undef;

our $verbose_command = '';
our @verbose_args;
our $verbose_command_formatted = undef;

our $last_verbose_report = 0;
our $verbose_row         = 0;

# Call it like this:
# while (<>) {
#   be_verbose_as_appropriate length;
#   ...
# }
sub be_verbose_as_appropriate {
  return unless $verbose;
  my ($record_length) = @_;
  $n_lines += !!$record_length;
  $n_bytes += $record_length;
  my $now = time;
  return unless $record_length == 0
             || ($now - $last_verbose_report) * 1000 > VERBOSE_INTERVAL;

  $last_verbose_report = $now;
  $verbose_command_formatted //= join ' ', $verbose_command, @verbose_args;
  $start_time //= $now;
  my $runtime = $now - $start_time || 1;
  printf STDERR "\033[%d;1H\033[K%10dl %8.1fl/s %10dk %8.1fkB/s  %s",
                $verbose_row,
                $n_lines,
                $n_lines / $runtime,
                $n_bytes / 1024,
                $n_bytes / 1024 / $runtime,
                $verbose_command_formatted;
}

END {
  be_verbose_as_appropriate 0;
  print STDERR "\n" if $verbose;
}

# This variable will keep track of any state accumulated from --use or --run
# arguments. This is required for --pmap to work correctly.
my @uses;

sub quote_self {join ' ', $0,
                map {/[^-\w]/ ? "'" . s/'/'\\''/gr . "'" : $_} @_}

my %explosions = (
  a => '--average',
  A => '--aggregate',
  c => '--count',
  D => '--drop',
  E => '--every',
  f => '--fields',
  F => '--fieldsplit',
  g => '--group',
  G => '--rgroup',
  i => '--index',
  I => '--indexouter',
  k => '--keep',
  K => '--remove',
  l => '--log',
  L => '--exp',
  m => '--map',
  M => '--pmap',
  n => '--number',
  o => '--order',
  O => '--rorder',
  p => '--plot',
  P => '--poll',
  q => '--quant',
  s => '--sum',
  S => '--delta',
  T => '--take',
  V => '--variance',
  w => '--with',
);

# Minimum number of required arguments for each function. Numeric arguments are
# automatically forwarded, so are always optional.
my %arity = (
  average    => 0,
  aggregate  => 1,
  count      => 0,
  delta      => 0,
  drop       => 0,
  every      => 0,
  fields     => 0,
  fieldsplit => 1,
  group      => 0,
  rgroup     => 0,
  index      => 2,
  indexouter => 2,
  keep       => 1,
  log        => 0,
  exp        => 0,
  map        => 1,
  pmap       => 1,
  number     => 0,
  order      => 0,
  rorder     => 0,
  plot       => 1,
  poll       => 2,
  sum        => 0,
  quant      => 0,
  remove     => 1,
  sample     => 0,
  take       => 0,
  variance   => 0,
  with       => 1,

  # Commands with no shorthands
  append     => 1,
  prepend    => 1,
  into       => 1,
  duplicate  => 2,
  partition  => 2,
  splot      => 1,
  sd         => 0,
  mplot      => 1,
  preview    => 0,
);

my %usages = (
  average    => 'window size (0 for full average) -- running average',
  aggregate  => 'aggregator fn',
  count      => 'counts by first column value; like uniq -c',
  delta      => 'value -> difference from last value',
  drop       => 'number of records to drop',
  every      => 'n (returns every nth row)',
  fields     => 'string of digits, each a zero-indexed column selector',
  fieldsplit => 'regexp to use for splitting',
  group      => 'sorts ascending',
  rgroup     => 'sorts descending',
  index      => 'field index, pseudofile to join against',
  indexouter => 'field index, pseudofile to join against',
  keep       => 'row filter fn',
  log        => 'log base e of each value',
  exp        => 'e^x for each value',
  map        => 'row map fn',
  pmap       => 'row map fn (executed multiple times in parallel)',
  number     => 'prepends line number to each line',
  order      => 'sorts ascending by general numeric value',
  rorder     => 'sorts descending by general numeric value',
  plot       => 'gnuplot arguments',
  poll       => 'interval in seconds, command whose output to collect',
  sum        => 'value -> total += value',
  quant      => 'number to round to',
  remove     => 'inverted row filter fn',
  sample     => 'row selection probability in [0, 1]',
  take       => 'n to take first n, +n to take last n',
  variance   => 'running variance',
  with       => 'command whose output to join column-wise onto input',

  append     => 'shell command; appends its output to current stream',
  prepend    => 'shell command; prepends its output to current stream',
  into       => 'shell command; copies stream into stdin of that command',
  duplicate  => 'two shell commands as separate arguments',
  partition  => 'partition id fn, shell command (where {} is partition ID)',
  splot      => 'gnuplot arguments',
  sd         => 'running standard deviation',
  mplot      => 'gnuplot arguments per column, separated by ;',
  preview    => '',
);

my %gnuplot_aliases = (
  '%l' => ' with lines',
  '%d' => ' with dots',
  '%i' => ' with impulses',
  '%u' => ' using ',
  '%t' => ' title ',
);

sub expand_gnuplot_options {
  my @transformed_opts;
  for my $opt (@_) {
    $opt =~ s/$_/$gnuplot_aliases{$_}/g for keys %gnuplot_aliases;
    push @transformed_opts, $opt;
  }
  @transformed_opts;
}

sub expand_eval_shorthands {
  $_[0] =~ s/%(\d+)/\$_[$1]/gr
        =~ s/\.([\$_a-zA-Z][-_\w?\$]*)/->{'$1'}/gr;
}

sub compile_eval_into_function {
  my ($code, $name) = @_;
  $code = expand_eval_shorthands $code;
  eval "sub {\n$code\n}"
    or die "failed to compile $name function: $@\n  (code was $code)";
}

sub stateless_unary_fn {
  my ($f) = @_;
  sub {
    my @columns = split //, shift // '0';
    while (<>) {
      be_verbose_as_appropriate length;
      chomp;
      my @fs = split /\t/;
      $fs[$_] = $f->($fs[$_], @_) for @columns;
      print row(@fs), "\n";
    }
  };
}

sub stateful_unary_fn {
  my ($setup, $f) = @_;
  sub {
    my @columns = split //, shift // '0';
    my %states;
    $states{$_} = $setup->(@_) for @columns;
    while (<>) {
      be_verbose_as_appropriate length;
      chomp;
      my @fs = split /\t/;
      $fs[$_] = $f->($fs[$_], $states{$_}, @_) for @columns;
      print row(@fs), "\n";
    }
  };
}

sub exec_with_stdin {
  open(my $fh, '|' . join(' ', map {"'$_'"} @_)) or die "failed to exec @_";
  be_verbose_as_appropriate(length), print $fh $_ while <>;
  close $fh;
}

sub exec_with_diamond {
  if (grep /\|/, @ARGV) {
    # Arguments are specified in filenames and involve processes, so use perl
    # to forward data.
    exec_with_stdin @_;
  } else {
    # Faster option: just exec the program in-place. This avoids a layer of
    # interprocess piping. Assume filenames follow arguments.
    exec @_, @ARGV or die "failed to exec @_ @ARGV";
  }
}

sub sort_options {
  my ($column) = @_;
  return '-S', $ENV{NFU_SORT_BUFFER} || '256M',
         '--parallel=' . ($ENV{NFU_SORT_PARALLEL} || 4),
         (defined $column
           ? ('-t', "\t", '-k', $column + 1)
           : ()),
         ($ENV{NFU_SORT_COMPRESS}
           ? ("--compress-program=$ENV{NFU_SORT_COMPRESS}")
           : ());
}

sub sort_cmd {join ' ', 'sort', sort_options, @_}

sub fifo_for {
  my ($file, @transforms) = @_;
  my $fifo_name = tmpnam;

  mkfifo $fifo_name, 0700 or die "failed to create fifo: $!";

  return $fifo_name if fork;

  my $command = expand_filename_shorthands($file, 1)
              . join '', map {"$_ |"} @transforms;
  open my $into_fifo, '>', $fifo_name
    or die "failed to open fifo $fifo_name for writing: $!";
  open my $from_file, $command
    or die "failed to open file/command $command for reading: $!";

  be_verbose_as_appropriate(length), $into_fifo->print($_) while <$from_file>;
  close $into_fifo;
  close $from_file;

  unlink $fifo_name or warn "failed to unlink temporary fifo $fifo_name: $!";
  exit 0;
}

my %functions = (
  group  => sub {exec_with_diamond 'sort', sort_options @_},
  rgroup => sub {exec_with_diamond 'sort', '-r', sort_options @_},
  order  => sub {exec_with_diamond 'sort', '-g', sort_options @_},
  rorder => sub {exec_with_diamond 'sort', '-rg', sort_options @_},

  count => sub {
    # Same behavior as uniq -c, but delimits counts with \t; also takes an
    # optional series of columns to uniq by, rather than using the whole row.
    my @columns = split //, shift // '';
    my $last;
    my @last;
    my $count = -1;

    while (<>) {
      be_verbose_as_appropriate length;
      chomp;

      my @xs = split /\t/;
      @xs   = @xs[@columns] if @columns;
      $last = $_, @last = @xs unless ++$count;

      for (my $i = 0; $i < @xs; ++$i) {
        if ($xs[$i] ne $last[$i]) {
          print "$count\t$last\n";
          $count = 0;
          @last  = @xs;
          $last  = $_;
          last;
        }
      }
    }

    ++$count;
    print "$count\t$last\n";
  },

  index => sub {
    # Inner join by appending joined fields to the end.
    my ($field_index, $join_file) = @_;
    ++$field_index;

    my $sorted_index = fifo_for $join_file, sort_cmd "-t '\t' -k1b,1";
    my $command = sort_cmd "-t '\t' -k ${field_index}b,$field_index" .
                  "| join -t '\t' -1 $field_index - '$sorted_index'";

    open my $to_join, "| $command" or die "failed to exec $command: $!";
    be_verbose_as_appropriate(length), print $to_join $_ while <>;
    close $to_join;
  },

  indexouter => sub {
    # Outer left join by appending joined fields to the end.
    my ($field_index, $join_file) = @_;
    ++$field_index;

    my $sorted_index = fifo_for $join_file, sort_cmd "-t '\t' -k 1b,1";
    my $command = sort_cmd "-t '\t' -k ${field_index}b,$field_index" .
                  "| join -a 1 -t '\t' -1 $field_index - '$sorted_index'";

    open my $to_join, "| $command" or die "failed to exec $command: $!";
    be_verbose_as_appropriate(length), print $to_join $_ while <>;
    close $to_join;
  },

  with => sub {
    # Like 'paste', but for commands. Joins lines with \t.
    my ($command) = @_;
    open my $fh, "$command |" or die "failed to exec $command: $!";
    my ($part1, $part2);
    while (defined($part1 = <>) and defined($part2 = <$fh>)) {
      be_verbose_as_appropriate length $part1 + length $part2;
      chomp $part1;
      chomp $part2;
      print "$part1\t$part2\n";
    }
    close $fh;
  },

  average => stateful_unary_fn(
    sub {my ($size, $n, $total) = ($_[0] // 0, 0, 0);
         [$size, $n, $total, []]},
    sub {
      my ($x, $state) = @_;
      my ($size, $n, $total, $window) = @$state;
      $total += $x;
      ++$n;
      my $v = $total / ($n > $size && $size ? $size : $n);
      $total -= shift @$window if $size and push(@$window, $x) >= $size;
      $$state[1] = $n;
      $$state[2] = $total;
      $v;
    }),

  aggregate => sub {
    my $f = compile_eval_into_function $_[0], 'aggregate function';
    my @columns;
    while (my $line = <>) {
      be_verbose_as_appropriate length $line;
      chomp $line;
      my @fields = split /\t/, $line;

      # Two cases here. If the new record is compatible with the most recent
      # existing one, or there aren't any existing ones, then group it and
      # don't call the aggregator yet.
      #
      # If we see a change, then call the aggregator and empty out the group.
      #
      # Note that the aggregator function is called on columns, not rows.

      my $n = @columns && @{$columns[0]};
      if (!$n or $fields[0] eq ${$columns[0]}[0]) {
        $columns[$_][$n] = $fields[$_] for 0 .. $#fields;
      } else {
        $_ = ${$columns[0]}[0];
        print $_, "\n" for $f->(@columns);
        @columns = ();
        $columns[$_][0] = $fields[$_] for 0 .. $#fields;
      }
    }
    if (@columns) {
      $_ = ${$columns[0]}[0];
      print $_, "\n" for $f->(@columns);
    }
  },

  log => stateless_unary_fn(sub {log $_[0]}),
  exp => stateless_unary_fn(sub {exp $_[0]}),

  quant => stateless_unary_fn(sub {
    my ($x, $quantum) = @_;
    $quantum ||= 1.0;
    my $sign = $x < 0 ? -1 : 1;
    int(abs($x) / $quantum + 0.5) * $quantum * $sign;
  }),

  # Note: this needs to be stdin; otherwise "nfu -p %l filename" will fail
  # (since exec_with_diamond trieds to pass filename straight into gnuplot).
  plot => sub {
    exec_with_stdin 'gnuplot',
                    '-e',
                    'plot "-" ' . join(' ', expand_gnuplot_options @_),
                    '-persist';
  },

  splot => sub {
    exec_with_stdin 'gnuplot',
                    '-e',
                    'splot "-" ' . join(' ', expand_gnuplot_options @_),
                    '-persist';
  },

  mplot => sub {
    my @gnuplot_options = split /;/, join ' ', expand_gnuplot_options @_;
    my $fname = tmpnam;
    open my $fh, '>', $fname or die "failed to open tempfile for mplot: $!";
    $fh->print($_) while <>;
    close $fh;
    system 'gnuplot', '-e',
           'plot ' . join(',', map("\"$fname\" $_", @gnuplot_options)),
           '-persist';
    unlink $fname or warn "failed to unlink mplot tempfile $fname: $!";
  },

  poll => sub {
    my ($sleep, $command) = @_;
    die "usage: --poll sleep-amount 'command ...'"
      unless defined $sleep and defined $command;
    system($command), sleep $sleep while 1;
  },

  delta => stateful_unary_fn(
    sub {[0]},
    sub {my ($x, $state) = @_;
         my $v = $x - $$state[0];
         $$state[0] = $x;
         $v}),

  sum => stateful_unary_fn(
    sub {[0]},
    sub {my ($x, $state) = @_;
         $$state[0] += $x}),

  variance => stateful_unary_fn(
    sub {[0, 0, 0]},
    sub {my ($x, $state) = @_;
         $$state[0] += $x;
         $$state[1] += $x * $x;
         $$state[2]++;
         my ($sx, $sx2, $count) = @$state;
         ($sx2 - ($sx * $sx / $count)) / $count}),

  sd => stateful_unary_fn(
    sub {[0, 0, 0]},
    sub {my ($x, $state) = @_;
         $$state[0] += $x;
         $$state[1] += $x * $x;
         $$state[2]++;
         my ($sx, $sx2, $count) = @$state;
         sqrt(($sx2 - ($sx * $sx / $count)) / $count)}),

  take => sub {
    if ($_[0] =~ s/^\+//) {
      # Take last n, so we need a line queue
      my @q;
      my $i = 0;
      $q[$i++ % $_[0]] = $_ while <>;
      print for @q[$i % $_[0] .. $#q];
      print for @q[0 .. $i % $_[0] - 1];
    } else {
      my $n = $_[0] // 1;
      while (<>) {
        last if --$n < 0;
        print;
      }
    }
  },

  sample => sub {
    while (<>) {
      be_verbose_as_appropriate length;
      print if rand() < $_[0];
    }
  },

  drop => sub {
    my $n = $_[0] // 1;
    while (<>) { last if --$n <= 0 }
    print while <>;
  },

  map => sub {
    my $f = compile_eval_into_function $_[0], 'map function';
    while (my $line = <>) {
      be_verbose_as_appropriate length $line;
      chomp $line;
      my @xs = split /\t/, $line;
      print "$_\n" for $f->(@xs);
    }
  },

  pmap => sub {
    my @fhs;
    my $wbits = '';
    my $wout  = '';
    my $i     = 0;

    for (1 .. $ENV{NFU_PMAP_PARALLELISM} // 16) {
      my $mapper = quote_self @uses, '--map', $_[0];
      open my $fh, "| $mapper"
        or die "failed to open child process $mapper: $!";

      vec($wbits, fileno($fh), 1) = 1;
      push @fhs, $fh;
    }

    while (<>) {
      be_verbose_as_appropriate;
      select undef, $wout = $wbits, undef, undef;
      ++$i until vec($wout, fileno $fhs[$i % @fhs], 1);
      syswrite $fhs[$i++ % @fhs], $_;
    }
    close for @fhs;
  },

  keep => sub {
    my $f = compile_eval_into_function $_[0], 'keep function';
    while (my $line = <>) {
      be_verbose_as_appropriate length $line;
      chomp $line;
      my @xs = split /\t/, $line;
      print row(@xs), "\n" if $f->(@xs);
    }
  },

  remove => sub {
    my $f = compile_eval_into_function $_[0], 'remove function';
    while (my $line = <>) {
      be_verbose_as_appropriate length $line;
      chomp $line;
      my @xs = split /\t/, $line;
      print row(@xs), "\n" unless $f->(@xs);
    }
  },

  every => sub {
    my ($n) = @_;
    my $i = 0;
    while (<>) {
      be_verbose_as_appropriate length;
      print unless $i++ % $n;
    }
  },

  fields => sub {
    my @fs = split //, $_[0];
    while (<>) {
      be_verbose_as_appropriate length;
      chomp;
      print join("\t", map $_ // '', (split /\t/)[@fs]), "\n";
    }
  },

  fieldsplit => sub {
    my $delim = qr/$_[0]/;
    while (<>) {
      be_verbose_as_appropriate length;
      chomp;
      print join("\t", split /$delim/), "\n";
    }
  },

  number => sub {
    my $n = 0;
    while (<>) {
      be_verbose_as_appropriate length;
      chomp;
      print row(++$n, $_), "\n";
    }
  },

  prepend => sub {
    system $_[0];
    print while <>;
  },

  append => sub {
    print while <>;
    system $_[0];
  },

  into => sub {
    open my $fh, "| $_[0]" or die "failed to launch $_[0]: $!";
    while (<>) {
      be_verbose_as_appropriate length;
      $fh->print($_);
      print;
    }
    close $fh;
  },

  duplicate => sub {
    open my $fh1, "| $_[0]" or die "failed to launch $_[0]: $!";
    open my $fh2, "| $_[1]" or die "failed to launch $_[1]: $!";
    while (<>) {
      be_verbose_as_appropriate length;
      $fh1->print($_);
      $fh2->print($_);
    }
    close $fh1;
    close $fh2;
  },

  partition => sub {
    my ($splitter, $cmd) = @_;
    my %fhs;
    $splitter =~ s/%(\d+)/\$_[$1]/g;
    my $f = compile_eval_into_function $splitter, 'partition function';

    my @open_partitions;
    while (<>) {
      be_verbose_as_appropriate length;
      my $line = $_;
      my $p    = $f->(split /\t/, $line);
      unless (exists $fhs{$p}) {
        my $cmdsub = $cmd =~ s/\{\}/$p/gr;
        open $fhs{$p}, "| $cmdsub" or die "failed to launch $cmdsub: $!";
        push @open_partitions, $p;
      }
      $fhs{$p}->print($line);
      close($p = shift @open_partitions), delete $fhs{$p}
        while @open_partitions > 256;
    }
    close for values %fhs;
  },

  preview => sub {
    my $have_less = !system 'which less > /dev/null';
    my $have_more = !system 'which more > /dev/null';

    my $less_program = $have_less ? 'less'
                     : $have_more ? 'more' : 'cat';

    exec_with_diamond $less_program;
  },
);

# Print usage if the user clearly doesn't know what they're doing.
if (@ARGV ? $ARGV[0] =~ /^-[h?]$/ || $ARGV[0] =~ /^--(usage|help)$/
          : -t STDIN) {

  # Some checks for me to make sure I'm keeping the code well-maintained
  exists $functions{$_}         or die "no function for $_" for keys %usages;
  exists $usages{$_}            or die "no usage for $_"    for keys %functions;
  exists $arity{$_}             or die "no arity for $_"    for keys %usages;
  exists $usages{$_ =~ s/--//r} or die "no usage for $_"
    for values %explosions, keys %usages;

  print STDERR "usage: nfu [prefix-commands...] [input-files...] commands...\n";
  print STDERR "where prefix commands are:\n\n";

  print STDERR "  documentation (not used with normal commands):\n";
  print STDERR "     --expand-pseudofile <filename>\n";
  print STDERR "     --expand-code       <code>\n";
  print STDERR "     --expand-gnuplot    <gnuplot options>\n";

  print STDERR "\n  pipeline modifiers:\n";
  print STDERR "     --quote  -- quotes args: eval \$(nfu --quote ...)\n";
  print STDERR "     --use    <file.pl>\n";
  print STDERR "     --run    <perl code>\n";

  print STDERR "\nand each command is one of the following:\n\n";

  my $len = 1 + max map length, keys %usages;
  my %short_lookup;
  $short_lookup{$explosions{$_} =~ s/^--//r} = $_ for keys %explosions;

  for my $cmd (sort keys %usages) {
    my $short = $short_lookup{$cmd};
    $short = defined $short ? "-$short|" : '   ';
    printf STDERR "  %s--%-${len}s %s\n",
                  $short,
                  $cmd,
                  $usages{$cmd} ? $arity{$cmd} ? "<$usages{$cmd}>"
                                               : "-- $usages{$cmd}" : '';
  }

  print STDERR "\ngnuplot expansions:\n\n";
  printf STDERR "  %2s -> '%s'\n", $_, $gnuplot_aliases{$_}
  for sort keys %gnuplot_aliases;

  print STDERR "\n";
  print STDERR "see https://github.com/spencertipping/nfu for documentation\n";
  print STDERR "\n";

  exit 1;
}

if (@ARGV && $ARGV[0] eq '--quote') {
  # Quote all other arguments so a shell will parse them correctly.
  shift @ARGV;
  print quote_self(@ARGV), "\n";
  exit 0;
}

if (@ARGV && $ARGV[0] =~ /^--expand/) {
  my ($command, $x, @others) = @ARGV;
  if ($command =~ /-pseudofile$/) {
    print expand_filename_shorthands($x) // '<invalid/nonexistent>', "\n";
  } elsif ($command =~ /-code$/) {
    print expand_eval_shorthands($x), "\n";
  } elsif ($command =~ /-gnuplot$/) {
    print expand_gnuplot_options($x), "\n";
  } else {
    print STDERR "unknown command: $command\n";
    exit 1;
  }
  exit 0;
}

sub explode {
  return $_[0] unless $_[0] =~ s/^-([^-])/$1/;
  map {$explosions{$_} // $_} grep length, split /([-+.\d]*),?/, $_[0];
}

my @exploded;
while (@ARGV) {
  # Load 'use' modules before any forking.
  if ($ARGV[0] =~ /^--(use|run)$/) {
    my $option = shift @ARGV;
    my $x      = shift @ARGV;

    push @uses, $option, $x;
    if ($option eq '--run') {
      eval $x;
      die "failed to run $x: $@" if $@;
    } else {
      do $x;
      die "failed to use $x: $@" if $@;
    }
  } elsif (!$verbose && $ARGV[0] =~ /^--?v(erbose)?$/) {
    shift @ARGV;
    print STDERR "\033[2J";
    $verbose = 1;
  } else {
    push @exploded, explode shift @ARGV;
  }
}

my $reader  = undef;
my @parsed  = ();
my $explain = 0;

@ARGV = ();

# First parse through all of the options, pull out stray files, and replace
# @ARGV. This enables <> in the worker subs. (The "right way" to do this would
# be to chain the commands' inputs; then I could remove the branch in the
# for-loop below. But I'm too lazy.)
while (@exploded) {
  (my $command = shift @exploded) =~ s/^--//;

  if (defined(my $arity = $arity{$command})) {
    my @args;
    push @args, shift @exploded while @exploded
                                   && (--$arity >= 0
                                       || $exploded[0] =~ /^[-+]?\d+/);
    push @parsed, [$command, @args];
  } elsif ($command eq 'explain') {
    $explain = 1;
  } else {
    my $f = expand_filename_shorthands $command;
    die "nonexistent pseudofile: $command" unless defined $f;
    push @ARGV, $f;
  }
}

# Open output in an interactive previewer if...
push @parsed, ['preview'] if !$ENV{NFU_NO_PAGER}    # we can page
                          && (!-t STDIN || @ARGV)   # not interacting for input
                          && -t STDOUT;             # interacting for output

if ($explain) {
  # Explain what we would have done with the given command line.
  printf "file\t%s\n", $_ for @ARGV;
  printf "--%s\t%s\n", ${$_}[0], join "\t",
                                 map "'$_'", @{$_}[1 .. $#$_] for @parsed;
} elsif (@parsed) {
  # Note: the loop below uses pipe/fork/dup2 instead of a more idiomatic Open2
  # call. I don't have a good reason for this other than to figure out how the
  # low-level stuff worked.
  for (my $i = 0; $i < @parsed; ++$i) {
    my ($command, @args) = @{$parsed[$i]};

    # Here's where things get fun. The question right now is, "do we need to
    # fork, or can we run in-process?" -- i.e. are we in the middle, or at the
    # end? When we're in the middle, we want to redirect STDOUT to the pipe's
    # writer and fork; otherwise we run in-process and write directly to the
    # existing STDOUT.
    ++$verbose_row;
    if ($i < @parsed - 1) {
      # We're in the middle, so allocate a pipe and fork.
      pipe my($new_reader), my($writer);
      $verbose_command = $command;
      @verbose_args    = @args;
      unless (fork) {
        # We're the child, so do STDOUT redirection.
        close $new_reader or die "failed to close pipe reader: $!";
        dup2(fileno($reader), 0) or die "failed to dup input: $!"
          if defined $reader;
        dup2(fileno($writer), 1) or die "failed to dup stdout: $!";

        close $reader or die "failed to close reader: $!" if defined $reader;
        close $writer or die "failed to close writer: $!";

        # The function here may never return.
        $functions{$command}->(@args);
        exit;
      } else {
        close $writer or die "failed to close pipe writer: $!";
        $reader = $new_reader;
      }
    } else {
      # We've hit the end of the chain. Preserve stdout, redirect stdin from
      # current reader.
      dup2(fileno($reader), 0) or die "failed to dup input: $!"
        if defined $reader;
      $verbose_command = $command;
      @verbose_args    = @args;
      $functions{$command}->(@args);
    }

    # Prevent <> from reading files after the first iteration (this is such a
    # hack).
    @ARGV = ();
  }
} else {
  # Behave like cat, which is useful for auto-decompressing things.
  be_verbose_as_appropriate(length), print while <>;
}
