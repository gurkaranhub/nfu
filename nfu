#!/usr/bin/env perl
# nfu: Command-line numeric fu | Spencer Tipping
# Licensed under the terms of the MIT source code license

use v5.10;
use strict;
use warnings;
use POSIX qw(dup2);

$|++;

my %explosions = (
  a => '--average',
  A => '--aggregate',
  c => '--count',
  d => '--delta',
  e => '--eval',
  E => '--every',
  f => '--fields',
  F => '--fieldsplit',
  g => '--group',
  G => '--rgroup',
  j => '--json',
  J => '--jsonflat',
  l => '--log',
  L => '--exp',
  o => '--order',
  O => '--rorder',
  s => '--sum',
  S => '--slice',
  q => '--quant',
  p => '--plot',
  P => '--poll',
  r => '--reduce',
);

my %arity = (
  average    => 1,
  aggregate  => 1,
  count      => 0,
  delta      => 0,
  eval       => 1,
  every      => 1,
  fields     => 1,
  fieldsplit => 1,
  group      => 0,
  rgroup     => 0,
  json       => 1,
  jsonflat   => 1,
  log        => 0,
  exp        => 0,
  order      => 0,
  rorder     => 0,
  plot       => 1,
  poll       => 2,
  sum        => 0,
  slice      => 2,
  quant      => 1,
  reduce     => 2,
);

sub exec_with_diamond {
  if (@ARGV) {
    # Arguments are specified in filenames and may be compressed, so use perl
    # to forward data.
    open(my $fh, '|' . join(' ', map {"'$_'"} @_)) or die "failed to exec @_";
    print $fh $_ while <>;
    close $fh;
  } else {
    # Faster option: just exec the program in-place. This avoids a layer of
    # interprocess piping.
    exec @_ or die "failed to exec @_";
  }
}

sub sort_options {
  '-S', $ENV{NFU_SORT_BUFFER} || '256M',
  '--parallel=' . ($ENV{NFU_SORT_PARALLEL} || 4),
  ($ENV{NFU_SORT_COMPRESS} ? ("--compress-program=$ENV{NFU_SORT_COMPRESS}")
                           : ())
}

my %functions = (
  group  => sub {exec_with_diamond 'sort', sort_options},
  rgroup => sub {exec_with_diamond 'sort', '-r', sort_options},
  order  => sub {exec_with_diamond 'sort', '-n', sort_options},
  rorder => sub {exec_with_diamond 'sort', '-rn', sort_options},

  count  => sub {
    # Same behavior as uniq -c, but delimits counts with \t
    chomp(my $last = <>);
    my $count = 1;
    while (<>) {
      chomp;
      if ($_ eq $last) {
        ++$count;
      } else {
        print "$count\t$last\n";
        $count = 1;
        $last  = $_;
      }
    }
    print "$count\t$last\n";
  },

  average => sub {
    my $size = $_[0];
    my ($n, $total) = (0, 0);
    my @window = ();
    while (<>) {
      chomp;
      my ($x, @xs) = split /\t/;
      print join("\t", ($total += $x) /
                       (++$n > $size && $size ? $size : $n), @xs), "\n";
      $total -= shift @window if $size and push(@window, $x) >= $size;
    }
  },

  aggregate => sub {
    (my $code = $_[0]) =~ s/%(\d+)/\$_[$1]/g;
    my $f = eval "sub {\n" . $code . "\n}" or
            die "failed to compile aggregate function: $@\n  (code was $code)";
    my @columns;
    while (my $line = <>) {
      chomp $line;
      my @fields = split /\t/, $line;

      # Two cases here. If the new record is compatible with the most recent
      # existing one, or there aren't any existing ones, then group it and
      # don't call the aggregator yet.
      #
      # If we see a change, then call the aggregator and empty out the group.
      #
      # Note that the aggregator function is called on columns, not rows.

      my $n = @columns && @{$columns[0]};
      if (!$n or $fields[0] eq ${$columns[0]}[0]) {
        $columns[$_][$n] = $fields[$_] for 0 .. $#fields;
      } else {
        $_ = ${$columns[0]}[0];
        print $_, "\n" for $f->(@columns);
        @columns = ();
        $columns[$_][0] = $fields[$_] for 0 .. $#fields;
      }
    }
    if (@columns) {
      $_ = ${$columns[0]}[0];
      print $_, "\n" for $f->(@columns);
    }
  },

  slice => sub {
    my ($chop_head, $chop_tail) = @_;
    die "usage: --slice head tail, or -Shead,tail"
      unless defined $chop_head and defined $chop_tail
         and $chop_head =~ /^\d+$/ and $chop_tail =~ /^\d+$/;
    my @window;
    my $n = 0;
    while (<>) {
      push @window, $_ if ++$n > $chop_head;
      print shift @window if @window > $chop_tail;
    }
  },

  log => sub {
    while (<>) {
      chomp;
      my ($x, @xs) = split /\t/;
      print join("\t", log($x), @xs), "\n";
    }
  },

  exp => sub {
    while (<>) {
      chomp;
      my ($x, @xs) = split /\t/;
      print join("\t", exp($x), @xs), "\n";
    }
  },

  plot => sub {exec_with_diamond 'gnuplot', '-e', "plot \"-\" @_", '-persist'},

  poll => sub {
    my ($sleep, $command) = @_;
    die "usage: --poll sleep-amount 'command ...'"
      unless defined $sleep and defined $command;
    system($command), sleep $sleep while 1;
  },

  delta => sub {
    my $last = 0;
    while (<>) {
      chomp;
      my ($x, @xs) = split /\t/;
      print join("\t", $x - $last, @xs), "\n";
      $last = $x;
    }
  },

  sum => sub {
    my $total = 0;
    while (<>) {
      chomp;
      my ($x, @xs) = split /\t/;
      print join("\t", $total += $x, @xs), "\n";
    }
  },

  quant => sub {
    my $quantum = $_[0] || 1.0;
    while (<>) {
      chomp;
      my ($x, @xs) = split /\t/;
      my $sign = $x < 0 ? -1 : 1;
      print join("\t", int(abs($x) / $quantum + 0.5) * $quantum * $sign, @xs),
            "\n";
    }
  },

  eval => sub {
    (my $code = $_[0]) =~ s/%(\d+)/\$_[$1]/g;
    my $f = eval "sub {\n" . $code . "\n}" or
            die "failed to compile eval function: $@\n  (code was $code)";
    local $_ = '';
    while (my $line = <>) {
      chomp $line;
      my @xs = split /\t/, $line;
      my @ys = $f->(@xs);
      print @ys > 1 ? join("\t", @ys)
                    : join("\t", $ys[0], @xs[1 .. $#xs]), "\n" if @ys;
    }
  },

  reduce => sub {
    (my $code = $_[1]) =~ s/%(\d+)/\$_[$1]/g;
    my $f = eval "sub {\n" . $code . "\n}" or
            die "failed to compile eval function: $@\n  (code was $code)";
    local $_ = $_[0];
    while (my $line = <>) {
      chomp $line;
      my @xs = split /\t/, $line;
      my @ys = $f->(@xs);
      print @ys > 1 ? join("\t", @ys)
                    : join("\t", $ys[0], @xs[1 .. $#xs]), "\n" if @ys;
    }
  },

  json => sub {
    require JSON or die 'nfu: unable to load JSON module';
    JSON->import;

    no warnings qw(uninitialized);

    my $body = $_[0] =~ s/%(\d+)/\$_[$1]/gr
                     =~ s/\.(\w+)/->{'$1'}/gr;

    my $json = JSON->new->allow_nonref->utf8(1);
    my $code = qq{sub {
      local \$_ = \$json->decode(\$_[0]);
      $body;
    }};

    my $f = eval $code
            or die "failed to compile eval function: $@\n  (code was $code)";

    while (<>) {
      chomp;
      my @xs = split /\t/;
      my @ys = $f->(@xs);
      print @ys > 1 ? join("\t", @ys)
                    : join("\t", $json->encode($ys[0]), @xs[1 .. $#xs]), "\n"
      if @ys;
    }
  },

  jsonflat => sub {
    require JSON or die 'nfu: unable to load JSON module';
    JSON->import;

    no warnings qw(uninitialized);

    my $body = $_[0] =~ s/%(\d+)/\$_[$1]/gr
                     =~ s/\.(\w+)/->{'$1'}/gr;

    my $json = JSON->new->allow_nonref->utf8(1);
    my $code = qq{sub {
      local \$_ = \$json->decode(\$_[0]);
      $body;
    }};

    my $f = eval $code
            or die "failed to compile eval function: $@\n  (code was $code)";

    while (<>) {
      chomp;
      my @xs = split /\t/;
      my @ys = $f->(@xs);
      print @ys > 1 ? join("\t", @ys)
                    : join("\t", $ys[0], @xs[1 .. $#xs]), "\n" if @ys;
    }
  },

  every => sub {
    my ($n) = @_;
    my $i = 0;
    while (<>) {
      print unless $i++ % $n;
    }
  },

  fields => sub {
    my @fs = split //, $_[0];
    chomp, print join("\t", (split /\t/)[@fs]), "\n" while <>;
  },

  fieldsplit => sub {
    my $delim = qr/$_[0]/;
    chomp, print join("\t", split /$delim/), "\n" while <>;
  },
);

sub explode {
  return $_ unless s/^-([^-])/$1/;
  map {$explosions{$_} // $_} grep length, split /([.\d]*),?/;
}

my $reader    = undef;
my $verbose   = shift @ARGV if $ARGV[0] eq '-v' || $ARGV[0] eq '--verbose';
my @exploded  = map explode, @ARGV;
my @parsed    = ();

my $pv_prefix = 'cat';
if ($verbose) {
  # Look for any number of pipe metering tools the user might have installed.
  my $have_pv        = !system 'which pv        > /dev/null';
  my $have_pipemeter = !system 'which pipemeter > /dev/null';
  my $have_cpipe     = !system 'which cpipe     > /dev/null';

  $pv_prefix = $have_pv        ? 'pv'
             : $have_pipemeter ? 'pipemeter'
             : $have_cpipe     ? 'cpipe -vt <' : 'cat';

  if ($pv_prefix eq 'cat') {
    print STDERR "nfu: requested verbose operation, but none of pv,\n";
    print STDERR "pipemeter, or cpipe is installed\n";
  }
}

@ARGV = ();

# First parse through all of the options, pull out stray files, and replace
# @ARGV. This enables <> in the worker subs. (The "right way" to do this would
# be to chain the commands' inputs; then I could remove the branch in the
# for-loop below. But I'm too lazy.)
while (@exploded) {
  (my $command = shift @exploded) =~ s/^--//;

  if (defined(my $arity = $arity{$command})) {
    my @args = splice @exploded, 0, $arity;
    push @parsed, [$command, @args];
  } elsif (-f $command) {
    # It's really a filename, so push it onto @ARGV. If it's compressed, run it
    # through the appropriate decompressor first.
    push @ARGV, "$pv_prefix " . ($command =~ s/^(.*\.gz)/$1 | gzip -d/ri
                                          =~ s/^(.*\.bz2)/$1 | bzip -d/ri
                                          =~ s/^(.*\.xz)/$1 | xz -d/ri
                                          =~ s/^(.*\.lzo)/$1 | lzop -d/ri)
                              . ' |';
  } else {
    die "nonexistent command/file: $command";
  }
}

if (@parsed) {
  # Note: the loop below uses pipe/fork/dup2 instead of a more idiomatic Open2
  # call. I don't have a good reason for this other than to figure out how the
  # low-level stuff worked.
  for (my $i = 0; $i < @parsed; ++$i) {
    my ($command, @args) = @{$parsed[$i]};

    # Here's where things get fun. The question right now is, "do we need to
    # fork, or can we run in-process?" -- i.e. are we in the middle, or at the
    # end? When we're in the middle, we want to redirect STDOUT to the pipe's
    # writer and fork; otherwise we run in-process and write directly to the
    # existing STDOUT.
    if ($i < @parsed - 1) {
      # We're in the middle, so allocate a pipe and fork.
      pipe my($new_reader), my($writer);
      unless (fork) {
        # We're the child, so do STDOUT redirection.
        close $new_reader or die "failed to close pipe reader: $!";
        dup2(fileno($reader), 0) or die "failed to dup input: $!"
          if defined $reader;
        dup2(fileno($writer), 1) or die "failed to dup stdout: $!";

        close $reader or die "failed to close reader: $!" if defined $reader;
        close $writer or die "failed to close writer: $!";

        # The function here may never return.
        $functions{$command}->(@args);
        exit;
      } else {
        close $writer or die "failed to close pipe writer: $!";
        $reader = $new_reader;
      }
    } else {
      # We've hit the end of the chain. Preserve stdout, redirect stdin from
      # current reader.
      dup2(fileno($reader), 0) or die "failed to dup input: $!"
        if defined $reader;
      $functions{$command}->(@args);
    }

    # Prevent <> from reading files after the first iteration (this is such a
    # hack).
    @ARGV = ();
  }
} else {
  # Behave like cat, which is useful for auto-decompressing things.
  print while <>;
}
